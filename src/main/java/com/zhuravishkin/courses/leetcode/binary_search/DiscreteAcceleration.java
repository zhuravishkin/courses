package com.zhuravishkin.courses.leetcode.binary_search;

/**
 * 1408C. Дискретное ускорение (https://codeforces.com/problemset/problem/1408/C?locale=ru)
 * Рассмотрим дорогу длиной l метров. Начало дороги имеет координату 0, конец дороги имеет координату l.
 * Есть две машины, первая стоит в начале дороги, вторая стоит в конце дороги. Они начинают ехать одновременно.
 * Первая машина будет ехать от начала дороги к концу, вторая машина будет ехать от конца дороги к началу.
 * Изначально они будут ехать со скоростью 1 метр в секунду. Есть n флажков, расположенных в различных координатах a1,a2,…,an.
 * Каждый раз, когда любая из двух машин проезжает мимо флажка, скорость этой машины увеличивается на 1 метр в секунду.
 * Найдите, через какое время машины встретятся (их координаты совпадут).
 * Входные данные
 * В первой строке находится единственное целое число t(1≤t≤10^4): количество наборов входных данных.
 * В первой строке описания каждого набора входных данных находятся два целых числа n, l (1≤n≤10^5, 1≤l≤10^9): количество флажков и длина дороги.
 * Во второй строке находятся n целых чисел a1,a2,…,an в возрастающем порядке (1≤a1<a2<…<an<l).
 * Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 10^5.
 * Выходные данные
 * Для каждого набора входных данных выведите единственное вещественное число: время, через которое машины встретятся.
 * Ваш ответ будет признан правильным, если его абсолютная или относительная ошибка не превосходит 10^−6. Более формально, если ваш ответ a и ответ жюри b,
 * ваш ответ будет признан правильным, если |a−b|/max(1,b)≤10^−6.
 * Пример
 * Входные данные
 * 5
 * 2 10
 * 1 9
 * 1 10
 * 1
 * 5 7
 * 1 2 3 4 6
 * 2 1000000000
 * 413470354 982876160
 * 9 478
 * 1 10 25 33 239 445 453 468 477
 * Выходные данные
 * 3.000000000000000
 * 3.666666666666667
 * 2.047619047619048
 * 329737645.750000000000000
 * 53.700000000000000
 * Примечание
 * В первом наборе входных данных машины встретятся в координате 5.
 * Первая машина будет в координате 1 через 1 секунду, и после этого ее скорость увеличится на 1 и станет равной 2-м метрам в секунду.
 * Через 2 секунды машина окажется в координате 5. Итак, первая машина будет в координате 5 через 3 секунды.
 * Вторая машина будет в координате 9 через 1 секунду, и после этого ее скорость увеличится на 1 и станет равной 2-м метрам в секунду.
 * Через 2 секунды машина окажется в координате 5. Итак, вторая машина будет в координате 5 через 3 секунды.
 * Во втором наборе входных данных через 1 секунду первая машина будет в координате 1 и будет иметь скорость, равную 2-м метрам в секунду;
 * вторая машина будет в координате 9 и будет иметь скорость 1 метр в секунду.
 * Поэтому после этого они встретятся через (9−1)/(2+1)=8/3 секунд. Итак, ответ равен 1+8/3=11/3.
 * Constraints:
 * ограничение по времени на тест: 3 секунды
 * ограничение по памяти на тест: 256 мегабайт
 */
public class DiscreteAcceleration {
    public static double run(int l, int[] a) {
        double left = 0;
        double right = l;
        double eps = 1e-7;
        while (right - left > eps) {
            double mid = (left + right) / 2;

            double leftPosition = 0;
            double leftSpeed = 1;
            double leftTime = mid;
            for (int flag : a) {
                double distanceToFlag = flag - leftPosition;
                double timeToFlag = distanceToFlag / leftSpeed;

                if (timeToFlag <= leftTime) {
                    leftPosition = flag;
                    leftTime -= timeToFlag;
                    leftSpeed++;
                } else {
                    leftPosition += leftTime * leftSpeed;
                    leftTime = 0;
                    break;
                }
            }
            leftPosition += leftTime * leftSpeed;

            double rightPosition = l;
            double rightSpeed = 1;
            double rightTime = mid;
            for (int i = a.length - 1; i >= 0; i--) {
                int flag = a[i];
                double distanceToFlag = rightPosition - flag;
                double timeToFlag = distanceToFlag / rightSpeed;

                if (timeToFlag <= rightTime) {
                    rightPosition = flag;
                    rightTime -= timeToFlag;
                    rightSpeed++;
                } else {
                    rightPosition -= rightTime * rightSpeed;
                    rightTime = 0;
                    break;
                }
            }
            rightPosition -= rightTime * rightSpeed;

            if (leftPosition >= rightPosition) {
                right = mid;
            } else {
                left = mid;
            }
        }

        return (left + right) / 2.0;
    }
}
